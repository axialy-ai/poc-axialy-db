# ── .github/workflows/axialy_db_aws.yml ───────────────────────────────────────
name: Axialy DB AWS

on:
  workflow_dispatch:
    inputs:
      db_identifier:
        required: true
        default: axialy-database-cluster
      aws_region:
        required: true
        default: us-west-1
      instance_class:
        required: true
        default: db.t3.micro
      allocated_storage:
        required: true
        default: "20"

      # ── Toggle flags ──────────────────────────────────────────────
      cleanup_after_run:
        description: "Destroy the stack once the run is finished (Option A)"
        type: boolean
        default: false
      import_existing:
        description: "Try to import any pre‑existing resources (Option B)"
        type: boolean
        default: true

env:
  AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

###############################################################################
# 1)  PREPARE – region validation, creds, backend guarantee, deep clean‑up
###############################################################################
jobs:
  prepare:
    runs-on: ubuntu-latest

    outputs:
      aws_region:   ${{ steps.region.outputs.aws_region }}
      tf_bucket:    ${{ steps.state.outputs.tf_bucket }}
      tf_lock_tbl:  ${{ steps.state.outputs.tf_lock_tbl }}

    steps:
      - uses: actions/checkout@v4

      # ── Region normaliser ─────────────────────────────────────────
      - name: Normalise AWS region input
        id: region
        shell: bash
        run: |
          REGION_IN="${{ github.event.inputs.aws_region }}"
          REGION_CLEAN="$(printf '%s' "$REGION_IN" | tr '–—−‑' '-')"
          [[ "$REGION_CLEAN" =~ ^[a-z]{2}-[a-z]+-[0-9]+$ ]] \
            || { echo "::error::Invalid AWS region"; exit 1; }

          echo "AWS_REGION=$REGION_CLEAN"          >> "$GITHUB_ENV"
          echo "AWS_DEFAULT_REGION=$REGION_CLEAN"  >> "$GITHUB_ENV"
          echo "aws_region=$REGION_CLEAN"          >> "$GITHUB_OUTPUT"

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ steps.region.outputs.aws_region }}

      # ── S3 & DynamoDB backend (and surface as job outputs) ────────
      - name: Ensure remote‑state backend exists
        id: state
        shell: bash
        run: |
          BUCKET=axialy-tf-state
          LOCK_TABLE=axialy-tf-lock

          aws s3 mb "s3://${BUCKET}" 2>/dev/null || true
          aws dynamodb create-table \
              --table-name "$LOCK_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema            AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST 2>/dev/null || true

          echo "TF_BUCKET=$BUCKET"          >> "$GITHUB_ENV"
          echo "TF_LOCK_TABLE=$LOCK_TABLE"  >> "$GITHUB_ENV"
          echo "tf_bucket=$BUCKET"          >> "$GITHUB_OUTPUT"
          echo "tf_lock_tbl=$LOCK_TABLE"    >> "$GITHUB_OUTPUT"

      # ── Deep hygiene: VPC quota + orphan resources + alias cleanup ─
      - name: Deep cleanup (Axialy VPCs & all descendants)
        shell: bash
        env:
          AWS_PAGER: ""
        run: |
          set -euo pipefail

          ######################################################################
          # 0) Quota sanity – raise the soft cap *and* clean‑up to stay under it
          ######################################################################
          echo "🔎 Checking regional VPC quota utilisation …"
          SERVICE_CODE="vpc"
          QUOTA_CODE="L-F678F1CE"   # “VPCs per Region”
          CUR_VPCS=$(aws ec2 describe-vpcs --query 'length(Vpcs)' --output text)
          CUR_LIMIT=$(aws service-quotas get-service-quota \
                         --service-code "$SERVICE_CODE" \
                         --quota-code   "$QUOTA_CODE" \
                         --query 'Quota.Value' --output text)
          echo "• Current usage: ${CUR_VPCS}/${CUR_LIMIT}"

          if [ "$CUR_VPCS" -ge "$CUR_LIMIT" ]; then
            DESIRED=$(( CUR_LIMIT + 5 ))
            echo "⚠️  VPC quota maxed‑out – requesting raise to ${DESIRED}"
            aws service-quotas request-service-quota-increase \
                 --service-code "$SERVICE_CODE" \
                 --quota-code   "$QUOTA_CODE" \
                 --desired-value "$DESIRED" 2>/dev/null || true
          fi

          ######################################################################
          # 1) Wipe conflicting KMS alias (must happen *before* TF runs)
          ######################################################################
          if aws kms list-aliases \
               --query 'Aliases[?AliasName==`alias/axialy-rds`]' \
               --output text | grep -q 'alias/axialy-rds'; then
            echo "🗑️  Deleting stale KMS alias/axialy-rds"
            aws kms delete-alias --alias-name alias/axialy-rds
          fi

          ######################################################################
          # 2) Purge every VPC tagged Name=axialy-* (plus ALL children).  The
          #    order strictly follows AWS dependency rules:
          #      • RDS (instances & clusters)  ➜ DB subnet groups
          #      • NAT GWs ➜ Endpoints ➜ ENIs ➜ IGWs ➜ NACLs ➜ RTs ➜ Subnets
          #      • SGs (non‑default) ➜ final VPC deletion
          ######################################################################
          orphan_vpcs=$(aws ec2 describe-vpcs \
                       --filters "Name=tag:Name,Values=axialy-*" \
                       --query 'Vpcs[].VpcId' --output text || true)

          for vpc in $orphan_vpcs; do
            echo "::group::🧹 Full purge of $vpc"

            # ────────────────────────────────────────────────────────
            # 2.1  RDS (instances & clusters) referencing this VPC
            #       ⤷ ensures subnet deletion won’t hit dependencies
            # ────────────────────────────────────────────────────────
            echo "🔻 Scanning for RDS resources inside $vpc"
            # ---- Instances ---------------------------------------------------
            for db in $(aws rds describe-db-instances \
                          --query 'DBInstances[].DBInstanceIdentifier' \
                          --output text); do
              v=$(aws rds describe-db-instances \
                     --db-instance-identifier "$db" \
                     --query 'DBInstances[0].DBSubnetGroup.VpcId' --output text)
              if [ "$v" = "$vpc" ]; then
                echo "• Deleting RDS instance $db"
                aws rds delete-db-instance \
                     --db-instance-identifier "$db" \
                     --skip-final-snapshot \
                     --delete-automated-backups \
                     --no-cli-pager
                aws rds wait db-instance-deleted \
                     --db-instance-identifier "$db"
              fi
            done
            # ---- Clusters ----------------------------------------------------
            for cluster in $(aws rds describe-db-clusters \
                               --query 'DBClusters[].DBClusterIdentifier' \
                               --output text); do
              sg_name=$(aws rds describe-db-clusters \
                          --db-cluster-identifier "$cluster" \
                          --query 'DBClusters[0].DBSubnetGroup' --output text)
              v=$(aws rds describe-db-subnet-groups \
                     --db-subnet-group-name "$sg_name" \
                     --query 'DBSubnetGroups[0].VpcId' --output text)
              if [ "$v" = "$vpc" ]; then
                echo "• Deleting RDS cluster $cluster"
                aws rds delete-db-cluster \
                     --db-cluster-identifier "$cluster" \
                     --skip-final-snapshot \
                     --no-cli-pager
                aws rds wait db-cluster-deleted \
                     --db-cluster-identifier "$cluster"
              fi
            done
            # ---- Subnet‑groups (now orphaned) --------------------------------
            for sg in $(aws rds describe-db-subnet-groups \
                           --query 'DBSubnetGroups[?VpcId==`'"$vpc"'`].DBSubnetGroupName' \
                           --output text); do
              echo "• Deleting DB subnet group $sg"
              aws rds delete-db-subnet-group \
                   --db-subnet-group-name "$sg" || true
            done

            # ────────────────────────────────────────────────────────
            # 2.2  NAT Gateways  ➜ release EIPs (after state=deleted)
            # ────────────────────────────────────────────────────────
            for ngw in $(aws ec2 describe-nat-gateways \
                           --filter Name=vpc-id,Values=$vpc \
                           --query 'NatGateways[].NatGatewayId' \
                           --output text || true); do
              echo "• Deleting NAT Gateway $ngw"
              alloc=$(aws ec2 describe-nat-gateways --nat-gateway-ids "$ngw" \
                       --query 'NatGateways[0].NatGatewayAddresses[0].AllocationId' \
                       --output text || true)
              aws ec2 delete-nat-gateway --nat-gateway-id "$ngw" || true
              aws ec2 wait nat-gateway-deleted --nat-gateway-ids "$ngw" || true
              [ -n "$alloc" ] && aws ec2 release-address --allocation-id "$alloc" || true
            done

            # ────────────────────────────────────────────────────────
            # 2.3  VPC Endpoints  ➜ wait until state = deleted
            # ────────────────────────────────────────────────────────
            for vpce in $(aws ec2 describe-vpc-endpoints \
                            --filters Name=vpc-id,Values=$vpc \
                            --query 'VpcEndpoints[].VpcEndpointId' \
                            --output text || true); do
              echo "• Deleting VPC Endpoint $vpce"
              aws ec2 delete-vpc-endpoints --vpc-endpoint-ids "$vpce" || true
              for _ in {1..60}; do
                state=$(aws ec2 describe-vpc-endpoints \
                           --vpc-endpoint-ids "$vpce" \
                           --query 'VpcEndpoints[0].State' --output text 2>/dev/null || echo deleted)
                [ "$state" = "deleted" ] && break
                sleep 5
              done
            done

            # ────────────────────────────────────────────────────────
            # 2.4  Detach & delete IGWs
            # ────────────────────────────────────────────────────────
            for igw in $(aws ec2 describe-internet-gateways \
                           --filters Name=attachment.vpc-id,Values=$vpc \
                           --query 'InternetGateways[].InternetGatewayId' \
                           --output text || true); do
              echo "• Deleting IGW $igw"
              aws ec2 detach-internet-gateway --internet-gateway-id "$igw" \
                                              --vpc-id "$vpc" || true
              aws ec2 delete-internet-gateway  --internet-gateway-id "$igw" || true
            done

            # ────────────────────────────────────────────────────────
            # 2.5  Custom NACLs
            # ────────────────────────────────────────────────────────
            for nacl in $(aws ec2 describe-network-acls \
                            --filters Name=vpc-id,Values=$vpc \
                            --query 'NetworkAcls[?IsDefault==`false`].NetworkAclId' \
                            --output text || true); do
              echo "• Deleting NACL $nacl"
              aws ec2 delete-network-acl --network-acl-id "$nacl" || true
            done

            # ────────────────────────────────────────────────────────
            # 2.6  Route‑tables & associations (non‑main)
            # ────────────────────────────────────────────────────────
            for rta in $(aws ec2 describe-route-tables \
                           --filters Name=vpc-id,Values=$vpc \
                           --query 'RouteTables[].Associations[?Main==`false`].RouteTableAssociationId' \
                           --output text || true); do
              aws ec2 disassociate-route-table --association-id "$rta" || true
            done
            for rtb in $(aws ec2 describe-route-tables \
                           --filters Name=vpc-id,Values=$vpc \
                           --query 'RouteTables[?Associations[?Main==`false`]].RouteTableId' \
                           --output text || true); do
              echo "• Deleting Route Table $rtb"
              aws ec2 delete-route-table --route-table-id "$rtb" || true
            done

            # ────────────────────────────────────────────────────────
            # 2.7  Subnets
            # ────────────────────────────────────────────────────────
            for subnet in $(aws ec2 describe-subnets \
                              --filters Name=vpc-id,Values=$vpc \
                              --query 'Subnets[].SubnetId' --output text || true); do
              echo "• Deleting Subnet $subnet"
              aws ec2 delete-subnet --subnet-id "$subnet" || true
            done

            # ────────────────────────────────────────────────────────
            # 2.8  Security groups (non‑default)
            # ────────────────────────────────────────────────────────
            for sg in $(aws ec2 describe-security-groups \
                           --filters Name=vpc-id,Values=$vpc \
                           --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
                           --output text || true); do
              echo "• Deleting Security Group $sg"
              aws ec2 delete-security-group --group-id "$sg" || true
            done

            # ────────────────────────────────────────────────────────
            # 2.9  Stray ENIs (must be *available*)
            # ────────────────────────────────────────────────────────
            for eni in $(aws ec2 describe-network-interfaces \
                           --filters Name=vpc-id,Values=$vpc Name=status,Values=available \
                           --query 'NetworkInterfaces[].NetworkInterfaceId' \
                           --output text || true); do
              echo "• Deleting ENI $eni"
              aws ec2 delete-network-interface --network-interface-id "$eni" || true
            done

            # ────────────────────────────────────────────────────────
            # 2.10 Final VPC delete + retry loop (up to 12× 5 s = 1 min)
            # ────────────────────────────────────────────────────────
            echo "• Deleting VPC $vpc"
            for try in {1..12}; do
              if aws ec2 delete-vpc --vpc-id "$vpc" 2>/dev/null; then
                echo "✔️  $vpc deleted"
                break
              fi
              echo "    ↪ dependency still present – retry ${try}/12"
              sleep 5
            done

            echo "::endgroup::"
          done
###############################################################################
# 2)  DEPLOY – create / update the entire stack (Terraform apply)
###############################################################################
  deploy:
    needs: prepare
    runs-on: ubuntu-latest

    env:
      AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION:            ${{ needs.prepare.outputs.aws_region }}
      AWS_DEFAULT_REGION:    ${{ needs.prepare.outputs.aws_region }}
      TF_BUCKET:             ${{ needs.prepare.outputs.tf_bucket }}
      TF_LOCK_TABLE:         ${{ needs.prepare.outputs.tf_lock_tbl }}

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6
          terraform_wrapper: false

      - name: Terraform init
        working-directory: infra/database-aws
        run: |
          cat > backend.tf <<EOF
          terraform {
            backend "s3" {
              bucket         = "${TF_BUCKET}"
              key            = "database-aws/terraform.tfstate"
              region         = "${AWS_REGION}"
              dynamodb_table = "${TF_LOCK_TABLE}"
              encrypt        = true
            }
          }
          EOF
          terraform init -input=false

      # ── (Option B) Import any pre‑existing pieces ─────────────────
      - name: Import existing resources (if enabled)
        if: ${{ github.event.inputs.import_existing }}
        working-directory: infra/database-aws
        shell: bash
        run: |
          set -euo pipefail
          DB_ID="${{ github.event.inputs.db_identifier }}"

          imp () {
            local addr=$1 id=$2
            if ! terraform state list | grep -q "^$addr$"; then
              echo "› importing $addr ($id)"
              terraform import "$addr" "$id" || true
            fi
          }

          # Subnet‑group
          aws rds describe-db-subnet-groups \
              --db-subnet-group-name axialy-db-subnet-group >/dev/null 2>&1 \
              && imp aws_db_subnet_group.axialy axialy-db-subnet-group

          # Log groups
          for lg in error general slowquery; do
            NAME="/aws/rds/instance/${DB_ID}/${lg}"
            aws logs describe-log-groups \
                 --log-group-name-prefix "$NAME" | jq -e '.logGroups|length>0' >/dev/null 2>&1 \
                 && imp "aws_cloudwatch_log_group.rds_${lg}" "$NAME"
          done

          # NAT EIPs
          for i in 1 2; do
            ALLOC=$(aws ec2 describe-addresses \
                      --filters "Name=tag:Name,Values=axialy-nat-eip-${i}" \
                      --query 'Addresses[0].AllocationId' --output text 2>/dev/null || true)
            [ "$ALLOC" != "None" ] && imp "aws_eip.nat[$((i-1))]" "$ALLOC"
          done

      # ── Terraform apply ───────────────────────────────────────────
      - name: Terraform apply
        id: tfout
        working-directory: infra/database-aws
        run: |
          terraform apply -auto-approve -input=false \
            -var="db_identifier=${{ github.event.inputs.db_identifier }}" \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="instance_class=${{ github.event.inputs.instance_class }}" \
            -var="allocated_storage=${{ github.event.inputs.allocated_storage }}"

          echo "db_endpoint=$(terraform output -raw db_endpoint)"            >> "$GITHUB_OUTPUT"
          echo "db_port=$(terraform output -raw db_port)"                    >> "$GITHUB_OUTPUT"
          echo "db_admin_user=$(terraform output -raw db_admin_user)"        >> "$GITHUB_OUTPUT"
          echo "db_admin_password=$(terraform output -raw db_admin_password)" >> "$GITHUB_OUTPUT"

###############################################################################
# 3)  CLEANUP – optional auto‑destroy when cleanup_after_run=true
###############################################################################
  cleanup:
    if: ${{ github.event.inputs.cleanup_after_run }}
    needs: [prepare, deploy]
    runs-on: ubuntu-latest

    env:
      AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION:            ${{ needs.prepare.outputs.aws_region }}
      AWS_DEFAULT_REGION:    ${{ needs.prepare.outputs.aws_region }}
      TF_BUCKET:             ${{ needs.prepare.outputs.tf_bucket }}
      TF_LOCK_TABLE:         ${{ needs.prepare.outputs.tf_lock_tbl }}

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6
          terraform_wrapper: false

      - name: Terraform init (remote state)
        working-directory: infra/database-aws
        run: |
          cat > backend.tf <<EOF
          terraform {
            backend "s3" {
              bucket         = "${TF_BUCKET}"
              key            = "database-aws/terraform.tfstate"
              region         = "${AWS_REGION}"
              dynamodb_table = "${TF_LOCK_TABLE}"
              encrypt        = true
            }
          }
          EOF
          terraform init -input=false

      - name: Destroy stack
        working-directory: infra/database-aws
        run: terraform destroy -auto-approve -input=false
